## 引用

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，其中 d是声明的变量名∶

```c++
int ival = 1024;
int &refVal = ival;  // refVal指向ival（是ival的另一个名字）
int &refVal2;        // 报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值`绑定（bind）`在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

**引用即别名**

`引用并非对象，相反的，它只是一个已经存在的对象所起的另一个名字`

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的∶

```c++
refVal = 2;        // 把 2 赋给 refVal 指向的对象，此处即是赋给了ival
int ii = refVal;   // 与 ii = ival执行结果一样
```


为引用赋值，实际上是把值赋给了与引用绑定的对象。

获取引用的值，实际上是获取了与引用绑定的对象的值。

同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值∶

```c++
// 正确∶ refVal3 绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上 
int srefVal3 = refVal;

// 利用与 refVal绑定的对象的值初始化变量 i 
int i = refVal;  // 正确∶i被初始化为ival的值
```

因为引用本身不是一个对象，所以不能定义引用的引用。

## 指针

指针（pointer）是"指向（point to）"另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。

其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。

其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成*d的形式，其中d是变量名。

```c++
int *ip1, *ip2;    // ip1和ip2都是指向int的指针
double dp, *dp2;   // dp2是指向double型对象的指针，dp是double型对象
```

获取对象的地址

指针存放某个对象的地址，想要获取该地址，需要使用取地址符（&）

```c++
int ival = 42;
int *p = &ival;  // p存放变量ival的地址，或者说p是指向变量ival的指针
```

因为`引用不是对象，没有实际地址`，所以不能定义指向引用的指针。

**利用指针访问对象**

如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象∶

```c++
int ival = 42;
int *p = &ival;   // p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p        // 由符号*得到指针 p 所指的对象，输出 42
```

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值∶

```c++
*p = 0;       // 由符号*得到指针 p所指的对象，即可经由p为变量ival赋值 
cout << *p;   // 输出0
```


如上述程序所示，为*p 赋值实际上是为 p 所指的对象赋值。

## 指针和引用的区别

指针"指向"内存中的某个对象，而引用"绑定到"内存中的某个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面∶

* 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象;引用不是一个对象，**无法令引用重新绑定到另外一个对象**。
* 第二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；**引用则必须在定义时赋初值**。