## 声明和定义

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

如果将程序分为多个文件，则需要有在文件间共享代码的方法。

例如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是`std::cout`和`std::cin`，它们定义于标准库，却能被我们写的程序使用。

为了支持分离式编译，C+语言将`声明`和`定义`区分开来。声明（declaration）使得名字为程序所知，`一个文件如果想使用别处定义的名字则必须包含对那个名字的声明`。而定义（definition）负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量∶

```c++
extern int i;    // 声明 i而
int j;           // 声明并定义 j int j;
```


任何包含了显式初始化的声明即成为定义。

我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了∶

```c++
extern double pi = 3.1416;       // 定义
```


在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

`变量能且只能被定义一次，但是可以被声明多次。`

声明和定义的区别看起来也许微不足道，但实际上却非常重要。

如果要在多个文件中使用同一个变量，就必须将声明和定义分离。

此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。







# 引用和指针

## 引用

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成`&d`的形式来定义引用类型，其中 d是声明的变量名∶

```c++
int ival = 1024;
int &refVal = ival;  // refVal指向ival（是ival的另一个名字）
int &refVal2;        // 报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值`绑定（bind）`在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

### 引用即别名

`引用并非对象，相反的，它只是一个已经存在的对象所起的另一个名字`

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的∶

```c++
refVal = 2;        // 把 2 赋给 refVal 指向的对象，此处即是赋给了ival
int ii = refVal;   // 与 ii = ival执行结果一样
```


为引用赋值，实际上是把值赋给了与引用绑定的对象。

获取引用的值，实际上是获取了与引用绑定的对象的值。

同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值∶

```c++
// 正确∶ refVal3 绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上 
int srefVal3 = refVal;

// 利用与 refVal绑定的对象的值初始化变量 i 
int i = refVal;  // 正确∶i被初始化为ival的值
```

因为引用本身不是一个对象，所以不能定义引用的引用。

## 指针

指针（pointer）是"指向（point to）"另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。

其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。

其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成*d的形式，其中d是变量名。

```c++
int *ip1, *ip2;    // ip1和ip2都是指向int的指针
double dp, *dp2;   // dp2是指向double型对象的指针，dp是double型对象
```

获取对象的地址

指针存放某个对象的地址，想要获取该地址，需要使用取地址符（&）

```c++
int ival = 42;
int *p = &ival;  // p存放变量ival的地址，或者说p是指向变量ival的指针
```

因为`引用不是对象，没有实际地址`，所以不能定义指向引用的指针。

### 利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象∶

```c++
int ival = 42;
int *p = &ival;   // p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p        // 由符号*得到指针 p 所指的对象，输出 42
```

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值∶

```c++
*p = 0;       // 由符号*得到指针 p所指的对象，即可经由p为变量ival赋值 
cout << *p;   // 输出0
```


如上述程序所示，为*p 赋值实际上是为 p 所指的对象赋值。

### 空指针

空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法∶

```c++
int *p1 = nullpter;  // 等价于int *p1 = 0;
int *p2 = 0;

//需要首先#include cstdlib
int *p3 = NULL;         // 等价于 int *p3 = 0;
```

得到空指针最直接的办法就是用字面值`nullptr`来初始化指针，这也是C+11新标准刚刚引入的一种方法。`nullptr`是一种特殊类型的字面值，它可以被转换成（参见2.1.2 节，

### void* 指针

`void*`是一种特殊的指针类型，可用于存放任意对象的地址。一个`void*`指针存放着一个地址，这一点和其他指针类似。

不同的是，我们对该地址中到底是个什么类型的对象并不了解∶

```c++
double obj = 3.14, *pd = &obj;	                        // 正确∶ void*
void *pv = &obj;				        // obj可以是任何类型的对象
pv = pd;						// pv 可以存放任意类型的指针			
```

利用`void*`能做的事儿比较有限∶ 拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个` void*`指针。

不能直接操作 `void*`指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

概括说来，以`void*`的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

