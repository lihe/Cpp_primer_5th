如果未定义析构函数，在销毁 HasPtr 对象时合成的析构函数==不会释放指针 ps指向的内存==，造成内存泄漏。

如果未定义拷贝构造函数，在拷贝 HasPtr 对象时，合成的拷贝构造函数会==简单复制==ps 成员，使得两个HasPtr指向相同的string。当其中一个 HasPtr修改 string 内容时，另一个 HasPtr也被改变，这并不符合我们的设想。如果同时定义了析构函数，情况会更为糟糕，当销毁其中一个HasPtr时，ps指向的 string被销毁，另一个 HasPtr的 ps 成为空悬指针。

